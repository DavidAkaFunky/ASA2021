
# **Aula Pratica 1**

## **Prob 4-1**

>1. T(n) = 2T(n/2) + n<sup>4</sup>

a=2, b=2, d=4  
log<sub>2</sub>2 = 1  < d  
Logo, T(n) = Θ(n<sup>4</sup>)

>2. T(n) = T(7n/10) + n

a=1, b=10/7, d=1  
log<sub>10/7</sub>1 = 0 < d  
Logo, T(n) = Θ(n)

>3. T(n) = 16T(n/4) + n<sup>2</sup>

a=16, b=4, d=2  
log<sub>4</sub>16 = 2 = d  
Logo, T(n) = Θ(n<sup>2</sup>*log(n))

>4. T(n) = 7T(n/3) + n<sup>2</sup>

a=7, b=3, d=2   
log<sub>3</sub>7 < 2  
Logo, T(n) = Θ(n<sup>2</sup>)

>5. T(n) = 7T(n/2) + n<sup>2</sup>

a=7, b=2, d=2  
2 < log<sub>2</sub>7 < 3  
Logo, T(n) = Θ(n<sup>log<sub>2</sub>7</sup>)  

>6. T(n) = 2T(n/4) + n<sup>1/2</sup>

a=2, b=4, d=1/2  
log<sub>4</sub>2 = 1/2 = d   
Logo, T(n) = Θ(n<sup>1/2</sup>*log(n))

>7. T(n) = T(n-2) + n<sup>2</sup>

= n<sup>2</sup> + T(n-2)  
= n<sup>2</sup> + (n-2)<sup>2</sup> + T(n-4)  
= n<sup>2</sup> + (n-2)<sup>2</sup> +  (n-4)<sup>2</sup> + T(n-6)  
...  
= Somatorio desde i=0 até i=n/2 de (n-2i)<sup>2</sup>    (Upper bound vem do facto de n-2i=0<=>n=21<=>i=n/2)  
= Desenvolver o quadrado e separar em 3 somatorios, dai concluir sobre a complexidade de cada um deles  
= Ver caderno :)

Logo, T(n)=Θ(n<sup>3</sup>)

## **Prob 4-3**

>1. T(n) = T(n-1) + log(n)

= log(n) + T(n-1)  
= log(n) + log(n-1) + T(n-2)  
= log(n) + log(n-1) + log(n-2) + T(n-3)  
= Somatorio desde i=0 até n-1 de log(n-i)  
= Soma em logaritmos podem ser transformados em produtos  
= log(n!)

Logo, T(n)=Θ(log(n!))

>2. T(n) = T(n-1) + 1/n

= 1/n + T(n-1)  
= 1/n + 1/(n-1) + T(n-2)  
= Somatorio desde i=0 até n-1 de 1/(n-i)  
= Pode ser transformado na serie harmonica

Logo, T(n)=Θ(log(n))

## **T1 de 13/14**

```
int f(int n)
{
    int i = 0;
    while(i < n)
        i++;
    if(n > 1)
        i = 2*f(n/4)+f(n/4);

    return i;
}
```
| k | i |
|---|---|
| 0 | 0 |
| 1 | 1 |
| 2 | 2 |
| k | k |

Condicao de paragem é i=n <=> k=n, ou seja o ciclo executa n vezes

T(n)=2T(n/4) + O(n)  
**Nota: Apenas chama a funcao recursivamente 2 vezes e nao 3**
a=2, b=5, d=1
log<sub>b</sub>a = 1/2 < d

Logo, T(n)=Θ(n)

## **R1 13/14 - II.a**

```
int f(int n)
{
    int j, i;
    
    j = 0;
    i = 0;
    while(i < n)
    {
        j++;
        i+= 2;
    }
    if(n > 1)
        i = 2*f(j) + f(j);

    return i;
}
```
| k | i  | j |
|---|----|---|
| 0 | 0  | 0 |
| 1 | 2  | 1 |
| 2 | 4  | 2 |
| k | 2k | k |

Condicao de paragem é i>=n <=> 2k>=n <=> k >= n/2  
Quantas iteracoes?  n/2

T(n)=2T(n/2) + O(n)  
a=2, b=2, d=1
log<sub>b</sub>a = 1 = d

Logo, T(n)=Θ(nlog(n))

## **T1 14/15 - II.e**

```
int f(int n)
{
    int i = 0;
    while(i*i < n)
        i++;
    if(n > 1)
        i = f(n/4) + f(n/4) + f(n/4);
    return i;
}
```
| k | i |
|---|---|
| 0 | 0 |
| 1 | 1 |
| 2 | 2 |
| k | k |

Condicao de paragem é i<sup>2</sup>>=n <=> k<sup>2</sup>>=n <=> k>=n<sup>1/2</sup>

T(n)=3T(n/4) + O(n<sup>1/2</sup>)  
a=3, b=4, d=1/2  
log<sub>b</sub>a > 1/2

Logo, T(n)=Θ(n<sup>log<sub>4</sub>3</sup>)


## **T1 16/17 - I.e**

```
int f(int n)
{
    int i = 0, j = 0;
    while(n*n > i) 
    {
        i = i + 2;
        j++;
    }

    if(n > 1)
        i = 5*f(n/2) + f(n/2) + f(n/2) + f(n/2);

    while (j > 0) 
    {
        i = i + 2;
        j--;
    }
    return i;
    }
```
| k | i  | j |
|---|----|---|
| 0 | 0  | 0 |
| 1 | 2  | 1 |
| 2 | 4  | 2 |
| 3 | 6  | 3 |
| k | 2k | k |

Condicao de paragem é i>=n<sup>2</sup> <=> 2k>=n<sup>2</sup> <=> k >= n<sup>2</sup>/2  
O(n<sup>2</sup>)
O segundo ciclo vai de j=n<sup>2</sup>/2 até zero logo também é O(n<sup>2</sup>)

T(n)=4T(n/2) + O(n<sup>2</sup>)  
a=4, b=2, d=2  
log<sub>b</sub>a = 2 = d

Logo, T(n)=Θ(n<sup>2</sup>log(n))




## **R1 16/17 - I.e**

```
int f(int n)
{
    int i = 0, j = 0;
    while (j < 10) {
        i = i + 2;
        j++;
    }

    if(n > 1)
        i += f(n/2) + 3*f(n/2);

    while (j > 0) {
        i--;
        j = j - 2;
    }
    return i;
}
```

| k | i  | j |
|---|----|---|
| 0 | 0  | 0 |
| 1 | 2  | 1 |
| k | 2k | k |

Condicao de paragem é j>=10 <=> k>=10

| k | i  |   j   |
|---|----|-------|
| 0 |    |   10  |
| 1 |    |    8  |
| k |    | 10-2k |

Condicao de paragem é j<=0 <=> 10-2k<=0 <=> k>=5

T(n)=2T(n/2) + O(1)  
a=4, b=2, d=0  
log<sub>b</sub>a = 1 > d

Logo, T(n)=Θ(n)

## **E1 18/19 - I.e**

```
int f(int n) {
    int i = 0, j = n;

    if (n <= 1) return 1;

    while(j > 0) {
        i++;
        j = j / 2;
    }

    for (int k = 0; k < 4; k++)
        j += f(n/2);

    while (i > 0) {
        j = j + 2;
        i--;
    }
    return j;
}
```
| k | i  | j               |
|---|----|-----------------|
| 0 | 0  | n               |
| 1 | 2  | n/2             |
| 2 | 4  | n/4             |
| 3 | 6  | n/8             |
| k | 2k | n/2<sup>k</sup> |

Condicao de paragem j<=0 <=> j<1 <=> n/2<sup>k</sup><1 <=> n<2<sup>k</sup> <=> k>log<sub>2</sub>n

O(log(n))

2ºLoop vai decrementar até ao inicio logo tambem é O(log(n))

T(n)=4T(n/2) + O(log(n))  
f(n) = log(n)
log<sub>b</sub>a = 2

log(n) < n<sup>2</sup> logo f(n) pertence a O(n<sup>2-e</sup>)

Logo, T(n)=Θ(n<sup>2</sup>)